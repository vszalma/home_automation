
import csv
import argparse
from pathlib import Path
from robocopy_helper import execute_robocopy
import home_automation_common
from datetime import datetime
import structlog

def _get_arguments():
    parser = argparse.ArgumentParser(
        description="Read similar folders from a CSV and call execute_robocopy for each."
    )
    parser.add_argument(
        "--input", "-i", required=True, type=str,
        help="Path to the CSV file generated by find_similar_folders.py"
    )
    parser.add_argument(
        "--destination", "-d", required=True, type=str,
        help="Path to the destination folder where files will be merged"
    )
    parser.add_argument(
        "--dry-run", action="store_true",
        help="If set, the script will simulate execution without performing actual robocopy"
    )
    parser.add_argument(
        "--cleanup", action="store_true",
        help="If set, the script will move files to an archive folder rather than copying them. This is useful for cleanup operations after a merge."
    )
    parser.add_argument(
        "--archive", "-a", required=False, type=str,
        help="Must exist if using --cleanup. This sets the location to archive files during a cleanup (a virtual delete)."
    )
    return parser.parse_args()

def _get_archive_path(source_path):

    relative = Path(*p.parts[1:])
    return relative


def main():

    today = datetime.now().date()

    log_file = f"{today}_merge_similar_folders.txt"

    log_file = home_automation_common.get_full_filename("log", log_file)

    home_automation_common.configure_logging(log_file)

    logger = structlog.get_logger()

    args = _get_arguments()
    input_path = Path(args.input)
    destination_path = Path(args.destination)

    if not input_path.is_file():
        print(f"Error: Input file not found: {input_path}")
        return
    if not destination_path.exists():
        print(f"Creating destination folder: {destination_path}")
        destination_path.mkdir(parents=True, exist_ok=True)

    with input_path.open("r", encoding="utf-8") as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            source_path = Path(row["folder_path"])
            if not source_path.exists():
                print(f"Skipping missing source: {source_path}")
                continue

            if args.cleanup:
                if not args.archive:
                    print("Error: --archive must be specified when using --cleanup")
                    return
                p = Path(source_path)
                relative_path = Path(*p.parts[1:])
                # archive_path = Path(r"\\?\\" + args.archive) / relative_path
                archive_path = Path(args.archive) / relative_path
                if not archive_path.exists():
                    print(f"Creating archive folder: {archive_path}")
                    archive_path.mkdir(parents=True, exist_ok=True)
                print(f"Archiving files from {source_path} to {archive_path}")
                # need to figure out how to handle the 
                execute_robocopy(
                    source=str(source_path),
                    destination=str(archive_path),
                    action="Move",
                    move=True
                )
                continue

            print(f"{'Dry-run: ' if args.dry_run else ''}Copying from {source_path} to {destination_path}")
            if not args.dry_run:
                execute_robocopy(
                    source=str(source_path),
                    destination=str(destination_path),
                    action="copy",
                    move=False
                )

if __name__ == "__main__":
    main()
